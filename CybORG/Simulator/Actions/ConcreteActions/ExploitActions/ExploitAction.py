## The following code contains work of the United States Government and is not subject to domestic copyright protection under 17 USC ยง 105.
## Additionally, we waive copyright and related rights in the utilized code worldwide through the CC0 1.0 Universal public domain dedication.
"""
Pertaining to actions that establish a new session on a host by exploiting
a process on that host
"""
from abc import abstractmethod
# pylint: disable=invalid-name
from ipaddress import IPv4Address

from CybORG.Shared import Observation
from CybORG.Simulator.Actions.Action import RemoteAction
from CybORG.Shared.Enums import ProcessType, OperatingSystemType, DecoyType
from CybORG.Simulator.Host import Host
from CybORG.Simulator.Process import Process
from CybORG.Simulator.Session import Session
from CybORG.Simulator.State import State


class ExploitAction(RemoteAction):
    """
    Base class for actions that establish a new session on a host by exploiting
    a process on that host
    """

    def __init__(self, session: int, agent: str, ip_address: IPv4Address):
        super().__init__(session, agent)
        self.ip_address = ip_address
        self.detection_rate = 0.95
        self.success_rate = 1.

    def get_used_route(self, state: State) -> list:
        """finds the route used by the action and returns the hostnames along that route"""
        return self.get_route(state, state.ip_addresses[self.ip_address], state.sessions[self.agent][self.session].hostname)

    def sim_exploit(self, state: State, port: int, process_type: str) -> Observation:
        """Attempts to exploit host, establishing a session on it"""
        obs = Observation(False)
        hostname = state.sessions[self.agent][self.session].hostname
        if not self.dropped:
            route = self.get_used_route(state)
            for other_hostname in route:
                host = state.hosts[other_hostname]
                if other_hostname == self.blocked:
                    event = {
                            'local_address': self.ip_address,
                            'remote_port': port,
                        'remote_address': {h_name: ip_addr for ip_addr, h_name in state.ip_addresses.items()}[hostname]

                    }
                    host.events['NetworkConnections'].append(event)
                    return obs
                elif 1 - self.detection_rate < state.np_random.random():
                    # add even to hosts along the path if detection occurs
                    event = {
                            'local_address': self.ip_address,
                            'remote_port': port,
                            'remote_address': {h_name: ip_addr for ip_addr, h_name in state.ip_addresses.items()}[hostname]
                            }
                    host.events['NetworkConnections'].append(event)
        else:
            return obs

        exploit_data = self._get_exploit_data(state, process_type, port)
        vuln_proc = exploit_data.get('vuln_proc')
        if vuln_proc is None:
            return obs

        target_process = self._get_target_process(port, process_type)
        obs.add_process(**target_process)
        exploit_works = self.test_exploit_works(**exploit_data)
        if not exploit_works or (1 - self.success_rate) > state.np_random.random():
            obs.add_interface_info(hostid=str(self.ip_address), ip_address=str(self.ip_address))
            return obs

        target_host = exploit_data['target_host']
        local_port = target_host.get_ephemeral_port()
        is_exploit_decoy = bool(vuln_proc.decoy_type & DecoyType.EXPLOIT)
        if is_exploit_decoy:
            event = {'local_address': self.ip_address, 'local_port': local_port}
            target_host.events['NetworkConnections'].append(event)
            obs.add_interface_info(hostid=str(self.ip_address), ip_address=str(self.ip_address))
            return obs

        new_session = self._create_new_session(state, obs, local_port, **exploit_data)
        if state.np_random.random() < self.detection_rate:
            self._create_new_session_event(new_session, local_port, **exploit_data)

        session_info = self._get_session_info(new_session)
        obs.add_session_info(**session_info)

        source_conn, target_conn = self._get_connections(local_port, **exploit_data)
        obs.add_process(**source_conn)
        obs.add_process(**target_conn)

        system_info = self._get_system_info(target_host)
        obs.add_system_info(**system_info)
        obs.set_success(True)

        return obs

    def _get_exploit_data(self, state, process_type, port):
        '''
        Gets the data needed to carry out the exploit. Returns early if any data
        unavailable.
        '''
        exploit_data = {}

        exploit_data['session'] = session = self._get_active_session(state)
        if session is None:
            return exploit_data

        from_host = state.hosts[session.hostname]
        exploit_data['from_ip'] = self._get_originating_ip(state, from_host, \
                self.ip_address)
        if exploit_data['from_ip'] is None:
            return exploit_data

        exploit_data['hostname'] = hostname = state.ip_addresses.get(self.ip_address)
        if hostname is None:
            return exploit_data

        exploit_data['target_host'] = target_host = state.hosts[hostname]
        if target_host is None:
            return exploit_data

        extension, path = self._get_path_extension(target_host)
        exploit_data['extension'] = extension
        exploit_data['path'] = path
        if None in (extension, path):
            return exploit_data

        exploit_data['vuln_proc'] = vuln_proc = self._get_vulnerable_process(
                target_host, exploit_data['from_ip'], process_type, port)

        return exploit_data

    def _get_active_session(self, state):
        '''
        Gets the active session specified in the class constructor. Returns None if this
        can\'t be found.
        '''

        if self.agent not in state.sessions:
            return None
        elif self.session not in state.sessions[self.agent]:
            return None

        session = state.sessions[self.agent][self.session]
        if not session.active:
            return None

        return session

    def _get_path_extension(self, target_host):
        if target_host.os_type == OperatingSystemType.WINDOWS:
            ext = 'exe'
            path = 'C:\\temp\\'
        elif target_host.os_type == OperatingSystemType.LINUX:
            ext = 'sh'
            path = '/tmp/'
        else:
            ext = None
            path = None

        return ext, path

    def _get_vulnerable_process(self, target_host, from_ip, process_type, port):
        '''
        Searches the state for the appropriate vulnerable process. Returns None if this \
                can\'t be found.
        '''
        vuln_proc = None
        for proc in target_host.processes:
            if proc.process_type == ProcessType.parse_string(process_type):
                for conn in proc.connections:
                    if 'local_port' in conn and conn['local_port'] == port:
                        vuln_proc = proc
                        target_host.events['NetworkConnections'].append(
                            {'local_address': self.ip_address,
                             'local_port': conn["local_port"],
                             'remote_address': from_ip,
                             'remote_port': target_host.get_ephemeral_port()})
                        break
                if vuln_proc is not None:
                    break

        return vuln_proc

    def _get_target_process(self, port, process_type):
        target_process = {
                'hostid': str(self.ip_address),
                'local_address': self.ip_address,
                'local_port': port,
                'status': "open",
                'process_type': process_type
                }

        return target_process

    def _create_new_session(self, state, obs, local_port, session, from_ip, target_host, \
            vuln_proc, extension, path, session_type='red_reverse_shell', **kwargs):
        source_connection = {
                "local_port": 4444,
               "Application Protocol": "tcp",
               "local_address": from_ip,
               "remote_address": self.ip_address,
               "remote_port": local_port
               }
        source_process = state.hosts[session.hostname].get_process(session.pid)
        source_process.connections.append(source_connection)

        target_connection = {
            "local_port": local_port,
            "Application Protocol": "tcp",
            "remote_address": from_ip,
            "remote_port": 4444,
            "local_address": self.ip_address
            }

        new_file = target_host.add_file(
                name=f'cmd.{extension}',
                path=path,
                user=vuln_proc.user,
                user_permissions=7,
                density=0.9,
                signed=False
                )
        proc = target_host.add_process(name=new_file.name, ppid=1, path=new_file.path, \
                user=vuln_proc.user)
        proc.connections.append(target_connection)

        is_sandbox = bool(vuln_proc.decoy_type & DecoyType.SANDBOXING_EXPLOIT)
        new_session = state.add_session(
                host=target_host.hostname,
                agent=self.agent,
                user=vuln_proc.user,
                session_type=session_type,
                parent=self.session,
                process=proc.pid,
                is_escalate_sandbox=is_sandbox
                )

        return new_session

    def _create_new_session_event(self, new_session, local_port, from_ip, target_host,\
            **kwargs):
        event = {
            'Connections':[{
                'local_address': self.ip_address,
                'local_port': local_port,
                'remote_address': from_ip,
                'remote_port': 4444}],
                'pid': new_session.pid
                }
        target_host.events['ProcessCreation'].append(event)


    def _get_session_info(self, new_session):
        session_info = {
                'hostid': str(self.ip_address),
                'session_id': new_session.ident,
                'session_type': new_session.session_type,
                'agent': self.agent
                }

        return session_info

    def _get_connections(self, local_port, from_ip, **kwargs):
        source_connection = {
                'hostid': str(from_ip),
                'local_address': from_ip,
                'remote_address': str(self.ip_address),
                'local_port': 4444,
                'remote_port': local_port,
                'process_type': 'reverse_session_handler'
                }

        target_connection = {
                'hostid': str(self.ip_address),
                'local_address': str(self.ip_address),
                'remote_address': from_ip,
                'local_port': local_port,
                'remote_port': 4444,
                'process_type': 'reverse_session'
                }

        return source_connection, target_connection

    def _get_system_info(self, target_host):
        system_info = {
                'hostid': str(self.ip_address),
                'hostname': target_host.hostname,
                'os_type': target_host.os_type
                }

        return system_info

    @abstractmethod
    def test_exploit_works(self, target_host: Host,
                           vuln_process: Process) -> bool:
        """
        check if OS and process information is correct for exploit to work.
        Return True if it will work given the vulnerable process vuln_process
        False otherwise
        """
        raise NotImplementedError

    def __add_reverse_session(self, *, state: State, username: str,
                              from_ip_address: IPv4Address, target_host: Host,
                              session: Session, is_escalate_sandbox: bool = False):
        """
        called when exploit is successful, establishes a new session on that host
        """
        if target_host.os_type == OperatingSystemType.WINDOWS:
            ext = 'exe'
            path = 'C:\\temp\\'
        elif target_host.os_type == OperatingSystemType.LINUX:
            ext = 'sh'
            path = '/tmp/'
        else:
            return Observation(False)
        obs = Observation()

        local_port = target_host.get_ephemeral_port()
        new_connection = {"local_port": local_port,
                          "Application Protocol": "tcp",
                          "remote_address": from_ip_address,
                          "remote_port": 4444,
                          "local_address": self.ip_address
                          }

        file = target_host.add_file(f'cmd.{ext}', path, username, 7, density=0.9, signed=False)
        proc = target_host.add_process(name=file.name, ppid=1, path=file.path, user=username)
        proc.connections.append(new_connection)
        new_session = state.add_session(host=target_host.hostname, agent=self.agent,
                                        user=username, session_type="red_reverse_shell", parent=self.session,
                                        process=proc.pid, is_escalate_sandbox=is_escalate_sandbox)

        if state.np_random.random() < self.detection_rate:
            target_host.events['NetworkConnections'].append({'local_address': self.ip_address,
                                                             'local_port': local_port,
                                                             'remote_address': from_ip_address,
                                                             'remote_port': 4444,
                                                             'pid': proc.pid})
        remote_port = {"local_port": 4444,
                       "Application Protocol": "tcp",
                       "local_address": from_ip_address,
                       "remote_address": self.ip_address,
                       "remote_port": local_port
                       }

        state.hosts[session.hostname].get_process(session.pid).connections.append(remote_port)
        obs.add_process(hostid=str(from_ip_address),
                        local_address=from_ip_address,
                        remote_address=str(self.ip_address),
                        local_port=4444,
                        remote_port=local_port,
                        process_type='reverse_session_handler')
        obs.add_process(hostid=str(self.ip_address),
                        local_address=str(self.ip_address),
                        remote_address=from_ip_address,
                        local_port=local_port,
                        remote_port=4444,
                        process_type='reverse_session')
        obs.add_session_info(hostid=str(self.ip_address),
                             session_id=new_session.ident,
                             session_type=new_session.session_type,
                             agent=self.agent)
        obs.add_system_info(hostid=str(self.ip_address), hostname=target_host.hostname,
                            os_type=target_host.os_type)
        obs.set_success(True)
        return obs

